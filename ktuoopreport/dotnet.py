"""
    Copyright (C) 2022 - Rokas Puzonas <rokas.puz@gmail.com>

    This file is part of KTU OOP Report Generator.

    KTU OOP Report Generator is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    KTU OOP Report Generator is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with KTU OOP Report Generator. If not, see <https://www.gnu.org/licenses/>.
"""
from typing import Optional
import os.path as path
from glob import glob
import os
import subprocess
from subprocess import PIPE
import stat
import fcntl
from shutil import copytree, rmtree
import contextlib
import time

@contextlib.contextmanager
def pushd(new_dir):
    previous_dir = os.getcwd()
    os.chdir(new_dir)
    yield
    os.chdir(previous_dir)

def is_project_root(project_root: str) -> bool:
    """
    Returns true if given directory contains a .csproj file
    """
    return path.isdir(project_root) and len(glob(path.join(project_root, "*.csproj"))) > 0

def find_executable(directory: str) -> Optional[str]:
    """
    Find file which is executable in directory. Or try guess which file should
    be the executable by .dll ending.
    """
    # Try searching for a file which is marked as executable
    for filename in glob(path.join(directory, "*")):
        if os.access(filename, os.X_OK):
            return filename

    # If this is some older .NET version if it isin't marked, find .dll file
    # And mark it as executable
    possible_executables = glob(path.join(directory, "*.dll"))
    if len(possible_executables) > 0:
        executable = possible_executables[0]
        os.chmod(executable, stat.S_IEXEC | stat.S_IREAD | stat.S_IWRITE)
        return executable

def build_project(project_root: str, output_directory: str, cli_args: list[str] = []) -> Optional[str]:
    """
    Build C# project using dotnet cli and output it to given directory
    """
    cmd = ["dotnet", "build", project_root, "-o", output_directory, *cli_args]
    process = subprocess.run(cmd, shell=False)

    # If failed to compile
    if process.returncode != 0:
        print(process.stderr)
        return None

    executable = find_executable(output_directory)
    if not executable:
        return None

    return executable

def remove_all_except(directory: str, ignored_file: str):
    """
    Clear all files, except specifies one
    """
    for item in glob(path.join(directory, "*")):
        if not path.samefile(item, ignored_file):
            if path.isfile(item):
                os.remove(item)
            elif path.isdir(item):
                rmtree(item)

def run_test(executable: str, test_folder: str):
    assert os.access(executable, os.X_OK), "Excpected to be able to run executable, insufficient permissions"
    assert path.isdir(test_folder), "Failed to verify that given test folder is a folder"

    print("RUN TESTS", test_folder)

    working_directory = path.dirname(executable)

    # Remove unnecessary files generated by cli
    remove_all_except(working_directory, executable)

    # copy current test files
    copytree(test_folder, working_directory, dirs_exist_ok=True)

    # Check if stdin is given
    stdin_lines = []
    stdin_file = path.join(working_directory, "stdin.txt")
    if path.isfile(stdin_file):
        with open(stdin_file, "r") as f:
            stdin_lines = f.read().strip().splitlines()
        os.remove(stdin_file)

    # Run program
    # TODO: Add better error handling when executable crashes
    with pushd(working_directory):
        proc = subprocess.Popen(["./"+path.basename(executable)], bufsize=0, shell=False, universal_newlines=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)

        # TODO: Refactor it's cross-platform.
        # This so it dosen't use the fcntl library, because it's posix only.
        # Available options to consider: threads, pexpect library.
        if proc.stdout:
            fcntl.fcntl(proc.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)

        # TODO: Refactor reading of stdout so it's not relying on timings
        # from time.sleep(0.1), because if the calculations of the executable
        # take a long time this system will break.
        stdout = ""
        if proc.stdin:
            for line in stdin_lines:
                if proc.poll() is not None:
                    break

                time.sleep(0.1)
                if proc.stdout:
                    try:
                        stdout += proc.stdout.read()
                    except IOError:
                        pass
                proc.stdin.write(line + "\n")
                proc.stdin.flush()
                stdout += line + "\n"

        proc.wait()
        if proc.stdout:
            try:
                stdout += proc.stdout.read()
            except IOError:
                pass

        return proc.returncode, stdout
